import { Strategy } from '@/types';

// OpenRouter AI configuration
const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const DEFAULT_MODEL = 'anthropic/claude-3-haiku:beta';

interface OpenRouterMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface OpenRouterResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
  error?: {
    message: string;
  };
}

export class OpenRouterAI {
  private apiKey: string;
  private model: string;

  constructor(apiKey?: string, model: string = DEFAULT_MODEL) {
    this.apiKey = apiKey || process.env.OPENROUTER_API_KEY || '';
    this.model = model;
    
    if (!this.apiKey) {
      throw new Error('OpenRouter API key is required');
    }
  }

  private async makeRequest(messages: OpenRouterMessage[]): Promise<string> {
    try {
      const response = await fetch(OPENROUTER_API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': process.env.NEXTAUTH_URL || 'http://localhost:3000',
          'X-Title': 'NexusTrade FX Platform',
        },
        body: JSON.stringify({
          model: this.model,
          messages,
          temperature: 0.7,
          max_tokens: 2000,
          response_format: { type: 'json_object' },
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data: OpenRouterResponse = await response.json();
      
      if (data.error) {
        throw new Error(data.error.message);
      }

      return data.choices[0]?.message?.content || '';
    } catch (error) {
      console.error('OpenRouter API error:', error);
      throw new Error(`Failed to generate strategy: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async generateStrategy(prompt: string): Promise<Partial<Strategy>> {
    const systemPrompt = `You are an expert forex trading strategy generator. Generate realistic trading strategies in JSON format only.

Your response must be a valid JSON object with the following structure:
{
  "name": "Strategy Name",
  "description": "Brief description of the strategy",
  "rules": [
    {
      "name": "Rule name",
      "conditions": [
        {
          "indicator": "price|sma_20|sma_50|ema_12|ema_26|rsi",
          "operator": "gt|lt|eq|gte|lte",
          "value": number,
          "timeframes": ["1h", "4h", "1d"]
        }
      ],
      "action": {
        "type": "buy|sell|close",
        "parameters": {
          "size": 0.01
        }
      }
    }
  ]
}

Guidelines:
- Use realistic indicators and values (RSI 30-70, SMAs for typical forex pairs)
- Focus on EUR/USD, GBP/USD, USD/JPY pairs
- Keep strategies simple and executable
- Include entry and exit rules
- Risk management is important (position sizes 0.01-0.1)
- Generate ONLY JSON, no additional text`;

    const messages: OpenRouterMessage[] = [
      {
        role: 'system',
        content: systemPrompt,
      },
      {
        role: 'user',
        content: `Generate a forex trading strategy based on this request: ${prompt}`,
      },
    ];

    const response = await this.makeRequest(messages);
    
    try {
      const strategyData = JSON.parse(response);
      
      // Validate and enhance the strategy
      return {
        id: `ai_${Date.now()}`,
        name: strategyData.name || 'AI Generated Strategy',
        description: strategyData.description || 'Strategy generated by AI',
        rules: Array.isArray(strategyData.rules) ? strategyData.rules : [],
        parameters: {
          riskPerTrade: 0.02,
          maxPositions: 1,
          stopLoss: 0.002,
          takeProfit: 0.004,
        },
        tags: this.generateTags(strategyData),
        isActive: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      };
    } catch (parseError) {
      console.error('Failed to parse AI response:', parseError);
      throw new Error('Invalid strategy format received from AI');
    }
  }

  async optimizeStrategy(strategy: Partial<Strategy>, performanceData: any): Promise<Partial<Strategy>> {
    const systemPrompt = `You are an expert forex strategy optimizer. Optimize the given strategy based on performance data.

Your response must be a valid JSON object with the following structure:
{
  "name": "Optimized Strategy Name",
  "description": "Description of optimization",
  "rules": [
    {
      "name": "Optimized rule name",
      "conditions": [
        {
          "indicator": "price|sma_20|sma_50|ema_12|ema_26|rsi",
          "operator": "gt|lt|eq|gte|lte",
          "value": number,
          "timeframes": ["1h", "4h", "1d"]
        }
      ],
      "action": {
        "type": "buy|sell|close",
        "parameters": {
          "size": 0.01
        }
      }
    }
  ],
  "parameters": {
    "riskPerTrade": 0.02,
    "maxPositions": 1,
    "stopLoss": 0.002,
    "takeProfit": 0.004
  }
}

Optimization guidelines:
- Analyze performance metrics (win rate, drawdown, profit factor)
- Adjust indicator values for better performance
- Improve risk management parameters
- Focus on realistic forex market conditions
- Keep strategy complexity manageable`;

    const userPrompt = `Optimize this strategy:
${JSON.stringify(strategy, null, 2)}

Performance data:
${JSON.stringify(performanceData, null, 2)}`;

    const messages: OpenRouterMessage[] = [
      {
        role: 'system',
        content: systemPrompt,
      },
      {
        role: 'user',
        content: userPrompt,
      },
    ];

    const response = await this.makeRequest(messages);
    
    try {
      const optimizedData = JSON.parse(response);
      
      return {
        ...strategy,
        name: optimizedData.name || strategy.name,
        description: optimizedData.description || strategy.description,
        rules: Array.isArray(optimizedData.rules) ? optimizedData.rules : strategy.rules,
        parameters: {
          ...strategy.parameters,
          ...optimizedData.parameters,
        },
        updatedAt: new Date(),
      };
    } catch (parseError) {
      console.error('Failed to parse optimization response:', parseError);
      throw new Error('Invalid optimization format received from AI');
    }
  }

  async analyzeMarketSentiment(symbol: string, timeframe: string): Promise<any> {
    const systemPrompt = `You are an expert forex market analyst. Analyze market sentiment and provide trading signals.

Your response must be a valid JSON object with the following structure:
{
  "sentiment": "bullish|bearish|neutral",
  "confidence": 0.85,
  "keyLevels": {
    "support": [1.0800, 1.0750],
    "resistance": [1.0900, 1.0950]
  },
  "recommendedActions": [
    {
      "action": "buy|sell|hold",
      "reason": "Brief explanation",
      "confidence": 0.80
    }
  ],
  "marketConditions": {
    "trend": "uptrend|downtrend|sideways",
    "volatility": "low|medium|high",
    "volume": "below_average|average|above_average"
  }
}

Analysis guidelines:
- Focus on major forex pairs (EUR/USD, GBP/USD, USD/JPY)
- Consider technical and fundamental factors
- Provide realistic support/resistance levels
- Give actionable recommendations with confidence scores
- Consider current market conditions and risk factors`;

    const userPrompt = `Analyze market sentiment for ${symbol} on ${timeframe} timeframe`;

    const messages: OpenRouterMessage[] = [
      {
        role: 'system',
        content: systemPrompt,
      },
      {
        role: 'user',
        content: userPrompt,
      },
    ];

    const response = await this.makeRequest(messages);
    
    try {
      return JSON.parse(response);
    } catch (parseError) {
      console.error('Failed to parse sentiment analysis:', parseError);
      throw new Error('Invalid sentiment analysis format received from AI');
    }
  }

  private generateTags(strategyData: any): string[] {
    const tags = ['ai-generated'];
    
    // Extract indicators used
    if (strategyData.rules) {
      strategyData.rules.forEach((rule: any) => {
        if (rule.conditions) {
          rule.conditions.forEach((condition: any) => {
            if (condition.indicator) {
              tags.push(condition.indicator);
            }
          });
        }
      });
    }
    
    // Add general strategy characteristics
    if (strategyData.description) {
      const desc = strategyData.description.toLowerCase();
      if (desc.includes('trend')) tags.push('trend-following');
      if (desc.includes('mean')) tags.push('mean-reversion');
      if (desc.includes('momentum')) tags.push('momentum');
      if (desc.includes('scalp')) tags.push('scalping');
      if (desc.includes('swing')) tags.push('swing-trading');
      if (desc.includes('breakout')) tags.push('breakout');
    }
    
    // Remove duplicates and limit to 10 tags
    return [...new Set(tags)].slice(0, 10);
  }

  async explainTrade(strategy: Partial<Strategy>, tradeData: any): Promise<string> {
    const systemPrompt = `You are an expert forex trading analyst. Explain trading decisions in simple, clear language.

Your response should be:
- Clear and concise (1-2 paragraphs)
- Educational for traders
- Explain the reasoning behind the trade
- Mention key indicators and market conditions
- Include risk considerations`;

    const userPrompt = `Explain this trade:

Strategy: ${JSON.stringify(strategy, null, 2)}

Trade Details:
${JSON.stringify(tradeData, null, 2)}`;

    const messages: OpenRouterMessage[] = [
      {
        role: 'system',
        content: systemPrompt,
      },
      {
        role: 'user',
        content: userPrompt,
      },
    ];

    return await this.makeRequest(messages);
  }

  // List of available models
  static getAvailableModels(): string[] {
    return [
      'anthropic/claude-3-haiku:beta',
      'anthropic/claude-3-sonnet:beta',
      'anthropic/claude-3-opus:beta',
      'openai/gpt-4-turbo-preview',
      'openai/gpt-4',
      'openai/gpt-3.5-turbo',
      'google/gemini-pro',
      'meta-llama/llama-3-70b-instruct',
    ];
  }
}

// Helper function to create AI instance
export function createOpenRouterAI(apiKey?: string, model?: string): OpenRouterAI {
  return new OpenRouterAI(apiKey, model);
}

// Export default instance for convenience
const defaultAI = new OpenRouterAI();
export default defaultAI;
